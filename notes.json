[
  {
    "date": "2025-01-11",
    "title": "Heap",
    "question": "Explain the types of heaps and how Python implements max heap using min heap.",
    "dsa_solution": null,
    "notes": [
      "Two types: Min Heap and Max Heap.",
      "Python doesn't have max heap natively, so we use a trick by inverting signs to mimic max heap.",
      "Heapify operation: O(n)",
      "Add/remove element: O(log n)",
      "Find min/max: O(1)"
    ],
    "example": {
      "input": "stones = [-s for s in stones]",
      "output": "Max heap created with negative values."
    },
    "link": null
  },
  {
    "date": "2025-01-12",
    "title": "Heap",
    "question": "Explain the types of heaps and how Python implements max heap using min heap.",
    "dsa_solution": null,
    "notes": [
      "Two types: Min Heap and Max Heap.",
      "Python doesn't have max heap natively, so we use a trick by inverting signs to mimic max heap.",
      "Heapify operation: O(n)",
      "Add/remove element: O(log n)",
      "Find min/max: O(1)"
    ],
    "example": {
      "input": "stones = [-s for s in stones]",
      "output": "Max heap created with negative values."
    },
    "link": null
  },
  {
    "date": "2025-01-18",
    "title": "Median from a Data Stream",
    "question": "Design a data structure to add numbers and find the median efficiently.",
    "dsa_solution": "class MedianFinder:\n\n    def __init__(self):\n        self.data = []\n\n    def addNum(self, num: int) -> None:\n        self.data.append(num)\n\n    def findMedian(self) -> float:\n        self.data.sort()\n        n = len(self.data)\n        return self.data[n//2] if n&1 else (self.data[n//2] + self.data[n//2-1])/2",
    "notes": [
      "Use a list to store numbers and sort it before finding the median.",
      "Efficient for small datasets."
    ],
    "example": {
      "input": "addNum(1), addNum(2), findMedian()",
      "output": "1.5"
    },
    "link": "https://leetcode.com/problems/find-median-from-data-stream/"
  },
  {
    "date": "2025-01-19",
    "title": "K-th Largest Element in a Stream",
    "question": "Design a class to find the k-th largest element in a stream.",
    "dsa_solution": "class KthLargest:\n\n    def __init__(self, k: int, nums: List[int]):\n        self.minHeap, self.k = nums, k\n        heapq.heapify(self.minHeap)\n        while len(self.minHeap) > k:\n            heapq.heappop(self.minHeap)\n\n    def add(self, val: int) -> int:\n        heapq.heappush(self.minHeap, val)\n        if len(self.minHeap) > self.k:\n            heapq.heappop(self.minHeap)\n        return self.minHeap[0]",
    "notes": [
      "Use a min heap to keep track of the k largest elements.",
      "Efficient as add and pop operations take O(log n)."
    ],
    "example": {
      "input": "k = 3, nums = [4, 5, 8, 2], add(3)",
      "output": "4"
    },
    "link": "https://leetcode.com/problems/kth-largest-element-in-a-stream/"
  },
  {
    "date": "2025-01-20",
    "title": "Last Stone Weight",
    "question": "Simulate the process of smashing stones, returning the weight of the last stone.",
    "dsa_solution": "class Solution:\n    def lastStoneWeight(self, stones: List[int]) -> int:\n        stones = [-s for s in stones]\n        heapq.heapify(stones)\n\n        while len(stones) > 1:\n            first = heapq.heappop(stones)\n            second = heapq.heappop(stones)\n            if second > first:\n                heapq.heappush(stones, first - second)\n\n        stones.append(0)\n        return abs(stones[0])",
    "notes": [
      "Convert the stone weights into a max heap using negative values.",
      "Simulate the process by repeatedly removing the two largest stones."
    ],
    "example": {
      "input": "stones = [2,7,4,1,8,1]",
      "output": "1"
    },
    "link": "https://leetcode.com/problems/last-stone-weight/"
  },
  {
    "date": "2025-01-21",
    "title": "K Closest Points to Origin",
    "question": "Find the k closest points to the origin (0,0) in a 2D plane.",
    "dsa_solution": "class Solution:\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n        minHeap = []\n\n        for x, y in points:\n            dist = x ** 2 + y ** 2\n            minHeap.append([dist, x, y])\n\n        heapq.heapify(minHeap)\n        res = []\n        while k > 0:\n            dist, x, y = heapq.heappop(minHeap)\n            res.append([x,y])\n            k -= 1\n        \n        return res",
    "notes": [
      "Use a min heap to store points based on their distance from the origin.",
      "Heapify ensures efficient extraction of the closest points."
    ],
    "example": {
      "input": "points = [[1,3],[-2,2]], k = 1",
      "output": "[[-2,2]]"
    },
    "link": "https://leetcode.com/problems/k-closest-points-to-origin/"
  },
  {
    "date": "2025-01-22",
    "title": "Find K-th Largest Element",
    "question": "Return the k-th largest element in an array.",
    "dsa_solution": "class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        nums = [-i for i in nums]\n        heapq.heapify(nums)\n\n        res = 0\n        while k > 0:\n            res = heapq.heappop(nums)\n            k -= 1\n        return res * -1",
    "notes": [
      "Use a max heap to extract the k largest elements.",
      "Efficient as heap operations are O(log n)."
    ],
    "example": {
      "input": "nums = [3,2,1,5,6,4], k = 2",
      "output": "5"
    },
    "link": "https://leetcode.com/problems/kth-largest-element-in-an-array/"
  }
]
