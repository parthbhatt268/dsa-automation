[
  {
    "date": "2025-01-11",
    "title": "Heap",
    "question": "Explain the types of heaps and how Python implements max heap using min heap",
    "dsa_solution": null,
    "notes": [
      "Two types: Min Heap and Max Heap.",
      "Python doesn't have max heap natively, so we use a trick by inverting signs to mimic max heap.",
      "Heapify operation: O(n)",
      "Add/remove element: O(log n)",
      "Find min/max: O(1)"
    ],
    "example": {
      "input": "stones = [-s for s in stones]",
      "output": "Max heap created with negative values."
    },
    "link": null
  },
  {
    "date": "2025-01-12",
    "title": "Heap",
    "question": "Explain the types of heaps and how Python implements max heap using min heap.",
    "dsa_solution": null,
    "notes": [
      "Two types: Min Heap and Max Heap.",
      "Python doesn't have max heap natively, so we use a trick by inverting signs to mimic max heap.",
      "Heapify operation: O(n)",
      "Add/remove element: O(log n)",
      "Find min/max: O(1)"
    ],
    "example": {
      "input": "stones = [-s for s in stones]",
      "output": "Max heap created with negative values."
    },
    "link": null
  },
  {
    "date": "2025-01-18",
    "title": "Median from a Data Stream",
    "question": "Design a data structure to add numbers and find the median efficiently.",
    "dsa_solution": "class MedianFinder:\n\n    def __init__(self):\n        self.data = []\n\n    def addNum(self, num: int) -> None:\n        self.data.append(num)\n\n    def findMedian(self) -> float:\n        self.data.sort()\n        n = len(self.data)\n        return self.data[n//2] if n&1 else (self.data[n//2] + self.data[n//2-1])/2",
    "notes": [
      "Use a list to store numbers and sort it before finding the median.",
      "Efficient for small datasets."
    ],
    "example": {
      "input": "addNum(1), addNum(2), findMedian()",
      "output": "1.5"
    },
    "link": "https://leetcode.com/problems/find-median-from-data-stream/"
  },
  {
    "date": "2025-01-19",
    "title": "K-th Largest Element in a Stream",
    "question": "Design a class to find the k-th largest element in a stream.",
    "dsa_solution": "class KthLargest:\n\n    def __init__(self, k: int, nums: List[int]):\n        self.minHeap, self.k = nums, k\n        heapq.heapify(self.minHeap)\n        while len(self.minHeap) > k:\n            heapq.heappop(self.minHeap)\n\n    def add(self, val: int) -> int:\n        heapq.heappush(self.minHeap, val)\n        if len(self.minHeap) > self.k:\n            heapq.heappop(self.minHeap)\n        return self.minHeap[0]",
    "notes": [
      "Use a min heap to keep track of the k largest elements.",
      "Efficient as add and pop operations take O(log n)."
    ],
    "example": {
      "input": "k = 3, nums = [4, 5, 8, 2], add(3)",
      "output": "4"
    },
    "link": "https://leetcode.com/problems/kth-largest-element-in-a-stream/"
  },
  {
    "date": "2025-01-20",
    "title": "Last Stone Weight",
    "question": "Simulate the process of smashing stones, returning the weight of the last stone.",
    "dsa_solution": "class Solution:\n    def lastStoneWeight(self, stones: List[int]) -> int:\n        stones = [-s for s in stones]\n        heapq.heapify(stones)\n\n        while len(stones) > 1:\n            first = heapq.heappop(stones)\n            second = heapq.heappop(stones)\n            if second > first:\n                heapq.heappush(stones, first - second)\n\n        stones.append(0)\n        return abs(stones[0])",
    "notes": [
      "Convert the stone weights into a max heap using negative values.",
      "Simulate the process by repeatedly removing the two largest stones."
    ],
    "example": {
      "input": "stones = [2,7,4,1,8,1]",
      "output": "1"
    },
    "link": "https://leetcode.com/problems/last-stone-weight/"
  },
  {
    "date": "2025-01-21",
    "title": "K Closest Points to Origin",
    "question": "Find the k closest points to the origin (0,0) in a 2D plane.",
    "dsa_solution": "class Solution:\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n        minHeap = []\n\n        for x, y in points:\n            dist = x ** 2 + y ** 2\n            minHeap.append([dist, x, y])\n\n        heapq.heapify(minHeap)\n        res = []\n        while k > 0:\n            dist, x, y = heapq.heappop(minHeap)\n            res.append([x,y])\n            k -= 1\n        \n        return res",
    "notes": [
      "Use a min heap to store points based on their distance from the origin.",
      "Heapify ensures efficient extraction of the closest points."
    ],
    "example": {
      "input": "points = [[1,3],[-2,2]], k = 1",
      "output": "[[-2,2]]"
    },
    "link": "https://leetcode.com/problems/k-closest-points-to-origin/"
  },
  {
    "date": "2025-01-22",
    "title": "Find K-th Largest Element",
    "question": "Return the k-th largest element in an array.",
    "dsa_solution": "class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        nums = [-i for i in nums]\n        heapq.heapify(nums)\n\n        res = 0\n        while k > 0:\n            res = heapq.heappop(nums)\n            k -= 1\n        return res * -1",
    "notes": [
      "Use a max heap to extract the k largest elements.",
      "Efficient as heap operations are O(log n)."
    ],
    "example": {
      "input": "nums = [3,2,1,5,6,4], k = 2",
      "output": "5"
    },
    "link": "https://leetcode.com/problems/kth-largest-element-in-an-array/"
  },
  {
    "date": "2025-01-26",
    "title": "Climbing Stairs",
    "question": "How many distinct ways can a person reach the nth step if they can jump 1 or 2 steps at a time?",
    "dsa_solution": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        one, two = 1, 1\n\n        for i in range(n-1):\n            temp = one + two\n            two = one\n            one = temp\n\n        return one",
    "notes": ["Fibonacci sequence problem solved with dynamic programming.", "Optimizes space complexity to O(1)."],
    "example": {"input": "n = 3", "output": "3"},
    "link": "https://leetcode.com/problems/climbing-stairs"
  },
  {
    "date": "2025-01-27",
    "title": "Min Cost Climbing Stairs",
    "question": "Find the minimum cost to reach the top of the floor starting from either step 0 or 1.",
    "dsa_solution": "class Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        cost.append(0)\n\n        for i in range(len(cost) - 3, -1, -1):\n            cost[i] = min(cost[i] + cost[i+1], cost[i] + cost[i+2])\n\n        return min(cost[0], cost[1])",
    "notes": ["Dynamic programming approach with bottom-up calculation.", "Modifies the cost array in reverse to accumulate minimum cost."],
    "example": {"input": "cost = [10, 15, 20]", "output": "15"},
    "link": "https://leetcode.com/problems/min-cost-climbing-stairs"
  },
  {
    "date": "2025-01-28",
    "title": "House Robber",
    "question": "Determine the maximum amount of money you can rob without alerting the police (adjacent houses).",
    "dsa_solution": "class Solution:\n    def rob(self, nums: List[int]) -> int:\n        rob1, rob2 = 0, 0\n\n        for n in nums:\n            newrob = max(rob1 + n, rob2)\n            rob1 = rob2\n            rob2 = newrob\n        \n        return rob2",
    "notes": ["Dynamic programming with O(n) time and O(1) space.", "Tracks two states: max profit up to previous or current house."],
    "example": {"input": "nums = [1, 2, 3, 1]", "output": "4"},
    "link": "https://leetcode.com/problems/house-robber"
  },
  {
    "date": "2025-01-29",
    "title": "House Robber II",
    "question": "Same as House Robber but with houses arranged in a circle.",
    "dsa_solution": "class Solution:\n    def rob(self, nums: List[int]) -> int:\n        return max(nums[0], self.helper(nums[1:]), self.helper(nums[:-1]))\n    \n    def helper(self, houses):\n        rob1, rob2 = 0, 0\n        \n        for n in houses:\n            newrob = max(rob1 + n, rob2)\n            rob1 = rob2\n            rob2 = newrob\n        \n        return rob2",
    "notes": ["Handles circular arrangement by splitting into two subproblems.", "Uses the same helper function as House Robber I."],
    "example": {"input": "nums = [2, 3, 2]", "output": "3"},
    "link": "https://leetcode.com/problems/house-robber-ii"
  },
  {
    "date": "2025-01-30",
    "title": "Longest Palindromic Substring",
    "question": "Find the longest substring that is a palindrome in a given string.",
    "dsa_solution": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        res = \"\"\n        resLen = 0\n\n        for i in range(len(s)):\n            l, r = i, i\n            while l >= 0 and r < len(s) and s[l] == s[r]:\n                if (r - l + 1) > resLen:\n                    res = s[l : r + 1]\n                    resLen = r - l + 1\n                l -= 1\n                r += 1\n\n            l, r = i, i + 1\n            while l >= 0 and r < len(s) and s[l] == s[r]:\n                if (r - l + 1) > resLen:\n                    res = s[l : r + 1]\n                    resLen = r - l + 1\n                l -= 1\n                r += 1\n\n        return res",
    "notes": ["Expands around each character as potential palindrome center.", "Handles both odd and even length palindromes."],
    "example": {"input": "s = \"babad\"", "output": "\"bab\""},
    "link": "https://leetcode.com/problems/longest-palindromic-substring"
  },
  {
    "date": "2025-01-31",
    "title": "Palindromic Substrings",
    "question": "Count the total number of palindromic substrings in a string.",
    "dsa_solution": "class Solution:\n    def countSubstrings(self, s: str) -> int:\n        res = 0\n\n        for i in range(len(s)):\n            res += self.countPali(s, i, i)\n            res += self.countPali(s, i, i + 1)\n        return res\n\n    def countPali(self, s, l, r):\n        res = 0\n        while l >= 0 and r < len(s) and s[l] == s[r]:\n            res += 1\n            l -= 1\n            r += 1\n        return res",
    "notes": ["Increments count for each valid palindrome during expansion.", "Time complexity O(n²)."],
    "example": {"input": "s = \"abc\"", "output": "3"},
    "link": "https://leetcode.com/problems/palindromic-substrings"
  },
  {
    "date": "2025-02-01",
    "title": "Decode Ways",
    "question": "Determine how many ways a string of digits can be decoded into letters (A-Z).",
    "dsa_solution": "class Solution:\n    def numDecodings(self, s: str) -> int:\n        dp = {len(s): 1}\n\n        def dfs(i):\n            if i in dp:\n                return dp[i]\n            if s[i] == \"0\":\n                return 0\n\n            res = dfs(i + 1)\n            if i + 1 < len(s) and (s[i] == \"1\" or s[i] == \"2\" and s[i + 1] in \"0123456\"):\n                res += dfs(i + 2)\n            dp[i] = res\n            return res\n\n        return dfs(0)",
    "notes": ["Handles edge cases with leading zeros and valid two-digit numbers.", "Uses memoization or dynamic programming for optimization."],
    "example": {"input": "s = \"12\"", "output": "2"},
    "link": "https://leetcode.com/problems/decode-ways"
  },
  {
    "date": "2025-02-02",
    "title": "Coin Change",
    "question": "Find the fewest number of coins needed to make up a given amount.",
    "dsa_solution": "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [amount + 1] * (amount + 1)\n        dp[0] = 0\n\n        for a in range(1, amount + 1):\n            for c in coins:\n                if a - c >= 0:\n                    dp[a] = min(dp[a], 1 + dp[a - c])\n        return dp[amount] if dp[amount] != amount + 1 else -1",
    "notes": ["Bottom-up dynamic programming approach.", "Initializes dp array with a large value (amount + 1)."],
    "example": {"input": "coins = [1, 2, 5], amount = 11", "output": "3"},
    "link": "https://leetcode.com/problems/coin-change"
  },
  {
    "date": "2025-02-03",
    "title": "Word Break",
    "question": "Determine if a string can be segmented into a space-separated sequence of dictionary words.",
    "dsa_solution": "class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        n = len(s)\n        word_set = set(wordDict)\n        dp = [False] * (n + 1)\n        dp[0] = True\n\n        for i in range(1, n + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in word_set:\n                    dp[i] = True\n                    break\n        return dp[n]",
    "notes": ["Uses a boolean dp array to track valid segmentation points.", "Breaks early if a valid segmentation is found."],
    "example": {"input": "s = \"leetcode\", wordDict = [\"leet\", \"code\"]", "output": "true"},
    "link": "https://leetcode.com/problems/word-break"
  },
  {
    "date": "2025-02-04",
    "title": "Longest Increasing Subsequence",
    "question": "Find the length of the longest subsequence where elements are in increasing order.",
    "dsa_solution": "class Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        LIS = [1] * len(nums)\n        \n        for i in range(len(nums) - 1, -1, -1):\n            for j in range(i + 1, len(nums)):\n                if nums[i] < nums[j]:\n                    LIS[i] = max(LIS[i], 1 + LIS[j])\n        \n        return max(LIS)",
    "notes": ["Dynamic programming with O(n²) time complexity.", "Iterates backwards to update LIS values."],
    "example": {"input": "nums = [10, 9, 2, 5, 3, 7, 101, 18]", "output": "4"},
    "link": "https://leetcode.com/problems/longest-increasing-subsequence"
  },
  {
    "date": "2025-02-05",
    "title": "Partition Equal Subset Sum",
    "question": "Can the array be partitioned into two subsets with equal sum?",
    "dsa_solution": "class Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        total = sum(nums)\n        if total % 2 != 0:\n            return False\n        target = total // 2\n        dp = set()\n        dp.add(0)\n        \n        for num in nums:\n            nextDP = set()\n            for t in dp:\n                if t + num == target:\n                    return True\n                nextDP.add(t + num)\n                nextDP.add(t)\n            dp = nextDP\n        return target in dp",
    "notes": ["Total sum must be even for a valid partition.", "Uses a set to track achievable subset sums dynamically."],
    "example": {"input": "nums = [1, 5, 11, 5]", "output": "true"},
    "link": "https://leetcode.com/problems/partition-equal-subset-sum"
  }
]
